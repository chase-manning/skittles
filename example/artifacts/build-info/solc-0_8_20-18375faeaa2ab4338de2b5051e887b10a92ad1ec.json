{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-18375faeaa2ab4338de2b5051e887b10a92ad1ec",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "build/solidity/Staking.sol": "project/build/solidity/Staking.sol",
    "build/solidity/Token.sol": "project/build/solidity/Token.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/build/solidity/Staking.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Staking {\n    enum VaultStatus { Active, Paused }\n\n    error NotOwner(address caller);\n    error VaultPaused();\n    error InsufficientDeposit(address account, uint256 deposited, uint256 requested);\n\n    struct IToken {\n        string name;\n        string symbol;\n        uint256 decimals;\n        uint256 totalSupply;\n    }\n\n    struct StakeInfo {\n        uint256 amount;\n        uint256 timestamp;\n        address account;\n    }\n\n    event Deposited(address indexed account, uint256 amount, uint256 timestamp);\n    event Withdrawn(address indexed account, uint256 amount);\n    event StatusChanged(uint256 newStatus);\n\n    uint256 public constant FEE_BASIS_POINTS = 50;\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;\n    address public immutable owner = msg.sender;\n    VaultStatus public status;\n    uint256 public totalDeposited = 0;\n    uint256 public totalFees = 0;\n    mapping(address => uint256) internal deposits;\n    mapping(address => uint256) internal depositTimestamps;\n\n    receive() external payable {\n        _deposit(msg.sender, msg.value);\n    }\n\n    function deposit() public payable virtual {\n        require((msg.value != 0), \"Must send ETH\");\n        _deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _requireActive();\n        if ((deposits[msg.sender] < amount)) {\n            revert InsufficientDeposit(msg.sender, deposits[msg.sender], amount);\n        }\n        uint256 fee = ((amount * Staking.FEE_BASIS_POINTS) / Staking.BASIS_POINTS_DENOMINATOR);\n        uint256 payout = (amount - fee);\n        deposits[msg.sender] -= amount;\n        totalDeposited -= amount;\n        totalFees += fee;\n        emit Withdrawn(msg.sender, payout);\n    }\n\n    function getStakeInfo(address account) public view virtual returns (StakeInfo memory) {\n        StakeInfo memory info = StakeInfo(deposits[account], depositTimestamps[account], account);\n        return info;\n    }\n\n    function getDeposit(address account) public view virtual returns (uint256) {\n        return deposits[account];\n    }\n\n    function getDepositTimestamp(address account) public view virtual returns (uint256) {\n        return depositTimestamps[account];\n    }\n\n    function pause() public virtual {\n        _requireOwner();\n        status = VaultStatus.Paused;\n        emit StatusChanged(1);\n    }\n\n    function unpause() public virtual {\n        _requireOwner();\n        status = VaultStatus.Active;\n        emit StatusChanged(0);\n    }\n\n    function _deposit(address account, uint256 amount) internal virtual {\n        _requireActive();\n        deposits[account] += amount;\n        depositTimestamps[account] = block.timestamp;\n        totalDeposited += amount;\n        emit Deposited(account, amount, block.timestamp);\n    }\n\n    function _requireOwner() internal view virtual {\n        if ((msg.sender != owner)) {\n            revert NotOwner(msg.sender);\n        }\n    }\n\n    function _requireActive() internal view virtual {\n        if ((status == VaultStatus.Paused)) {\n            revert VaultPaused();\n        }\n    }\n}\n"
      },
      "project/build/solidity/Token.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Token {\n    enum VaultStatus { Active, Paused }\n\n    error InsufficientBalance(address sender, uint256 balance, uint256 required);\n    error InsufficientAllowance(address spender, uint256 allowance, uint256 required);\n\n    struct IToken {\n        string name;\n        string symbol;\n        uint256 decimals;\n        uint256 totalSupply;\n    }\n\n    struct StakeInfo {\n        uint256 amount;\n        uint256 timestamp;\n        address account;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    string public name = \"Skittles Token\";\n    string public symbol = \"SKT\";\n    uint256 public decimals = 18;\n    uint256 public totalSupply = 0;\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowances;\n\n    constructor(uint256 initialSupply) {\n        totalSupply = initialSupply;\n        balances[msg.sender] = initialSupply;\n        emit Transfer(address(0x0000000000000000000000000000000000000000), msg.sender, initialSupply);\n    }\n\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        uint256 currentAllowance = allowances[from][msg.sender];\n        if ((currentAllowance < amount)) {\n            revert InsufficientAllowance(msg.sender, currentAllowance, amount);\n        }\n        if ((currentAllowance != type(uint256).max)) {\n            _approve(from, msg.sender, (currentAllowance - amount));\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        if ((balances[from] < amount)) {\n            revert InsufficientBalance(from, balances[from], amount);\n        }\n        balances[from] -= amount;\n        balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"
      }
    }
  }
}