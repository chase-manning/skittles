---
slug: /
sidebar_position: 1
title: Introduction
---

# Skittles

**Write smart contracts in TypeScript. Compile to Solidity.**

<img
  src="https://skittles.dev/banner.png"
  alt="Skittles"
  style={{ width: "100%", borderRadius: "12px", marginBottom: "2rem" }}
/>

Skittles is a TypeScript to Solidity compiler. You write EVM smart contracts as TypeScript classes using syntax you already know, and Skittles compiles them into clean, auditable Solidity source code. Use Hardhat to compile that Solidity to ABI and EVM bytecode.

```typescript title="contracts/Token.ts"
import { address, msg, SkittlesEvent, Indexed } from "skittles";

export class Token {
  Transfer: SkittlesEvent<{
    from: Indexed<address>;
    to: Indexed<address>;
    value: number;
  }>;

  name: string = "My Token";
  symbol: string = "TKN";
  totalSupply: number = 0;
  balances: Record<address, number> = {};

  constructor(initialSupply: number) {
    this.totalSupply = initialSupply;
    this.balances[msg.sender] = initialSupply;
  }

  transfer(to: address, amount: number): boolean {
    if (this.balances[msg.sender] < amount) {
      throw new Error("Insufficient balance");
    }
    this.balances[msg.sender] -= amount;
    this.balances[to] += amount;
    this.Transfer.emit({ from: msg.sender, to, value: amount });
    return true;
  }
}
```

This compiles to a Solidity contract with events, mappings, a constructor, and a transfer function, all with correct state mutability, visibility, and memory annotations.

## How It Works

Skittles takes your TypeScript classes through a three stage pipeline:

1. **Parse** — The TypeScript AST is parsed using the official TypeScript compiler API. Classes become contracts, properties become state variables, methods become functions.

2. **Generate** — The intermediate representation is converted to valid Solidity. Type mappings, visibility, state mutability inference, and optimizations like `if/throw` to `require()` are applied automatically.

3. **Compile** — The generated Solidity is written to `build/solidity/`. Hardhat (or another Solidity toolchain) compiles it to ABI and EVM bytecode.

```
TypeScript (.ts) → Parser → IR → Codegen → Solidity (.sol) → Hardhat → ABI + Bytecode
```

## Features

- **Types** that map to Solidity: `number` → `uint256`, `string`, `boolean` → `bool`, `address`, `bytes`, `Record<K,V>` → `mapping`, `T[]` → arrays, interfaces → structs, enums
- **State variables** with visibility (`public`, `private`), `readonly` for immutable, `static readonly` for constant
- **Functions** with automatic state mutability inference (`pure`, `view`, `payable`), `virtual`/`override`, getters/setters, `receive()`, and `fallback()`
- **Events** via `SkittlesEvent<T>` with `Indexed<T>` parameter support
- **Custom errors** via `SkittlesError<T>` or `class extends Error`
- **Inheritance** with `extends` and `super`
- **Control flow**: `if`/`else`, `for`, `while`, `do`/`while`, `for...of`, `switch`/`case`, ternary
- **EVM globals**: `msg.sender`, `msg.value`, `block.timestamp`, `block.number`, `tx.origin`, and more
- **Built in functions**: `keccak256()`, `sha256()`, `ecrecover()`, `abi.encode()`, `abi.encodePacked()`
- **Cross file support**: shared structs, enums, constants, and functions across contract files
- **Incremental compilation**: SHA256 based file caching, only recompiles what changed

## Build Output

```
build/
  solidity/     # Generated Solidity source (.sol)
```

Skittles writes Solidity to `build/solidity/`. Configure Hardhat's `paths.sources` to point there and run `hardhat compile` or `hardhat test` to produce ABI and bytecode. The output is compatible with ethers.js, viem, Foundry, and every other EVM tool.

## Next Steps

- [Installation](/getting-started/installation) to get Skittles set up
- [Quick Start](/getting-started/quick-start) to compile your first contract
- [Type System](/guide/types) to understand how TypeScript types map to Solidity
- [Examples](/examples/erc20-token) to see real contracts
